<!DOCTYPE html>
<html lang="en-us">
  <head>
    <title>Elixir 0-Arity Functions: Drop the Parens? - jtmoulia</title>
    <meta charset="utf-8" />
    <meta name="author" content="Thomas Moulia" />
    <meta name="description" content="Include the parens when calling 0 arity functions?" />
    <meta name="keywords" content="elixir, style, erlang, parentheses, parens, function, variable" />
    <link rel="stylesheet" href="/media/css/main.css" type="text/css">
    <link rel="stylesheet" href="/media/css/prettify.css" type="text/css">
  </head>
  <body class="container">
    <div>
      <header class="masthead">
        <h1 class="masthead-title"><a href="/">jtmoulia</a></h1>
        <p>public notebook ðŸ““</p>
        <ul>
          <li><a href="/blog/">Blog</a></li>
          <li><a href="/tags/">Tags</a></li>
          <li><a href="/about/">About</a></li>
          <li><a href="http://github.com/jtmoulia">GitHub</a></li>
          <li><a href="/rss.xml">RSS</a></li>
        </ul>
        <form method="get" id="searchform" action="http://www.google.com/search">
          <input type="text" class="field" name="q" id="s" placeholder="Search">
          <input type="hidden" name="as_sitesearch" value="jtmoulia.pocketknife.io">
        </form>
      </header>
    </div>

<div>
<div class="post">
<h1>Elixir 0-Arity Functions: Drop the Parens?</h1>
<p>
A question <a href="https://github.com/niftyn8/elixir_style_guide">from github</a>: <code>func</code> or <code>func()</code> ? And, my opinion...
</p>

<p>
tl;dr; consistent use of trailing parens increases code clarity by
explicitly signaling whether a reference is being used as a function
call or a variable. Style decisions are case by case, but I'd default
to keeping the parens when calling a 0 arity function.
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Elixir + Barewords</h2>
<div class="outline-text-2" id="text-1">
<p>
Elixir's Ruby heritage is apparent in its expressive and flexible
syntax -- Elixir is unabashed about adding syntactic sugar to make
your life easier.
</p>

<p>
In particular, it carries over what Avdi Grimm calls Ruby's
"barewords", references without decoration which can refer to
different things depending on the context. While it sounds exotic,
barewords are fundamental to the Elixir, e.g. variable references
are barewords. <code>thing</code> or <code>Module.thing</code> is a bareword, while
<code>thing()</code> or <code>Module</code> are not. Functions without arguments may be
called using the function's name as a bareword, i.e. <code>func</code> and
<code>func()</code>.
</p>

<p>
In Elixir, a bareword is evaluated by first checking the bareword's
name (the bareword itself) against variables in the context. If it
isn't a defined variable, Elixir attempts to call the name as a
function with no arguments. This doesn't have any special error
handling: a <code>RuntimeError</code> is raised if the function is undefined:
</p>

<div class="org-src-container">

<pre class="src src-elixir">iex&gt; a
** (RuntimeError) undefined <span style="color: #87cefa;">function:</span> a/0

iex&gt; a()
** (RuntimeError) undefined <span style="color: #87cefa;">function:</span> a/0
</pre>
</div>

<p>
Here's an example of how barewords are first checked against the
variables in the context, then called as a function:
</p>

<div class="org-src-container">

<pre class="src src-elixir"><span style="color: #F92672;">defmodule</span> <span style="color: #66D9EF;">Example</span> <span style="color: #F92672;">do</span>

  <span style="color: #F92672;">def</span> <span style="color: #A6E22E;">five</span>, <span style="color: #87cefa;">do:</span> 5

  <span style="color: #d8bfd8;">@doc</span> <span style="color: #E6DB74;">"""</span>
<span style="color: #E6DB74;">  Returns the function `five`, 5 in this case, plus `x`.</span>
<span style="color: #E6DB74;">  """</span>
  <span style="color: #F92672;">def</span> <span style="color: #A6E22E;">five_plus_fn</span>(x) <span style="color: #F92672;">do</span>
    five + x
  <span style="color: #F92672;">end</span>

  <span style="color: #d8bfd8;">@doc</span> <span style="color: #E6DB74;">"""</span>
<span style="color: #E6DB74;">  Returns the variable `five`, 4 in this case, plus `x`.</span>
<span style="color: #E6DB74;">  """</span>
  <span style="color: #F92672;">def</span> <span style="color: #A6E22E;">five_plus_var</span>(x) <span style="color: #F92672;">do</span>
    <span style="color: #FD971F;">five</span> = 4
    five + x
  <span style="color: #F92672;">end</span>
<span style="color: #F92672;">end</span>

<span style="color: #AE81FF;">IO</span>.inspect [[<span style="color: #87cefa;">:five_plus_fn</span>,  Example.five_plus_fn(5)],
            [<span style="color: #87cefa;">:five_plus_var</span>, Example.five_plus_var(5)]]
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="right" />
</colgroup>
<tbody>
<tr>
<td class="left">:five_plus_fn</td>
<td class="right">10</td>
</tr>

<tr>
<td class="left">:five_plus_var</td>
<td class="right">9</td>
</tr>
</tbody>
</table>
</div>
</div>


<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">For Keeping Parens</h2>
<div class="outline-text-2" id="text-2">
<p>
<code>func()</code>
</p>

<p>
Unless I have a good reason, I default to using parens because of
the clarity it adds to the code.
</p>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">Clarity</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Using parens to call 0 arity functions increases code clarity by
explicitly signaling that the reference is a function.
</p>

<p>
Reading code is a non-linear process of untangling threads of logic
until you understand the whole. Having contextual signals (funcall
vs var) makes references easier to trace.
</p>

<p>
The other day, <a href="https://twitter.com/bismark">Ryan Johnson</a> was digging around in
<a href="https://github.com/elixir-lang/elixir/blob/69c1cf27b0c491fb9b489fb1ed0f6f6a5ce31816/lib/ex_unit/lib/ex_unit/case.ex#L203">ExUnit.Case.test/2,3</a>. He asked:
</p>

<blockquote>
<p>
what does `binding` refer to?
</p>
</blockquote>

<p>
Here's the macro in question, trimmed down for easy digestion:
</p>

<div class="org-src-container">

<pre class="src src-elixir"><span style="color: #F92672;">defmacro</span> test(message, var \\ <span style="color: #F92672;">quote</span>(<span style="color: #87cefa;">do:</span> <span style="color: #AE81FF;">_</span>), contents) <span style="color: #F92672;">do</span>
  <span style="color: #FD971F;">contents</span> = ...
  <span style="color: #FD971F;">var</span>      = <span style="color: #AE81FF;">Macro</span>.escape(var)
  <span style="color: #FD971F;">contents</span> = <span style="color: #AE81FF;">Macro</span>.escape(contents, <span style="color: #87cefa;">unquote:</span> true)

  <span style="color: #F92672;">quote</span> <span style="color: #87cefa;">bind_quoted:</span> binding <span style="color: #F92672;">do</span>
    <span style="color: #FD971F;">test</span> = :<span style="color: #E6DB74;">"test </span><span style="color: #FD971F;">#{message}</span><span style="color: #E6DB74;">"</span>
    <span style="color: #AE81FF;">ExUnit</span>.Case.__on_definition__(<span style="color: #AE81FF;">__ENV__</span>, test)
    <span style="color: #F92672;">def</span> <span style="color: #F92672;">unquote</span>(test)(<span style="color: #F92672;">unquote</span>(var)), <span style="color: #87cefa;">do:</span> <span style="color: #F92672;">unquote</span>(contents)
  <span style="color: #F92672;">end</span>
<span style="color: #F92672;">end</span>
</pre>
</div>

<p>
Here's the process for figuring out what <code>binding</code>, or any
bareword, refers to:
</p>

<ol class="org-ol">
<li>Are there any variables bound to <code>binding</code> in the context?
It's a bit easier in the example above since I cut out half of
the macro at the <code>...</code>. Answer: no
</li>
<li>Are there any 0 arity functions called <code>binding</code> defined in
<code>ExUnit.Case</code> ? Answer: no
</li>
<li>Are there any 0 arity functions called <code>binding</code> imported by
<code>ExUnit.Case</code>? <code>ExUnit.Case</code> imports four modules, any of which
might define the function. Answer: yes
</li>
<li>Still can't find it? Try starting back at (1).
</li>
</ol>

<p>
This process is trivial for a computer brain running the correct
program, but our human brains are not nearly as well equipped to
glean the answer from source code. If you know of any tooling that
helps with this, let me know!
</p>

<p>
After some spelunking, Ryan found did find the answer to his
question in the nifty <a href="http://elixir-lang.org/docs/stable/elixir/Kernel.html#binding/1">binding/0</a> macro. However, even if he'd known
about <code>Kernel.binding/0</code>, he still would have had to verify that
their are no variables named <code>binding</code> which supersede the function
call.
</p>

<p>
If <code>binding()</code> had been used instead of <code>binding</code>, you could
scratch step 1: the parens signal that the reference is to a
function rather than a variable. Moreover, if you're wiser than
Ryan and I and know of <code>Kernel.binding/0</code>, your job is easy.
</p>

<p>
In complex code where reference tracing is already difficult,
forcing the reader to check through multiple contexts is painful
and unnecessary.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">For Dropping Parens</h2>
<div class="outline-text-2" id="text-3">
<p>
<code>func</code>
</p>

<p>
Dogma has no place in coding style -- here are some situations
where it might make sense to drop the parens:
</p>
</div>

<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">One Name, Multiple Contexts</h3>
<div class="outline-text-3" id="text-3-1">
<p>
The bareword duality between variables and function calls allows
for easy refactoring from a variable to a function call with no
arguments. The follow two code snippets show how most <a href="http://elixir-lang.org/docs/stable/mix/">Mixfiles</a> take
advantage of this:
</p>

<div class="org-src-container">

<pre class="src src-elixir"><span style="color: #F92672;">defmodule</span> <span style="color: #66D9EF;">MyApp.Mixfile</span> <span style="color: #F92672;">do</span>
  <span style="color: #F92672;">def</span> <span style="color: #A6E22E;">project</span> <span style="color: #F92672;">do</span>
    <span style="color: #FD971F;">deps</span> = [{<span style="color: #87cefa;">:ecto</span>, <span style="color: #E6DB74;">"~&gt; 0.8.0"</span>}]
    [<span style="color: #87cefa;">app:</span> <span style="color: #87cefa;">:my_app</span>,
     <span style="color: #87cefa;">deps:</span> deps]
  <span style="color: #F92672;">end</span>
<span style="color: #F92672;">end</span>
</pre>
</div>

<p>
The punchline: refactoring out the <code>deps</code> variable to its own
function without changing the reference to it:
</p>

<div class="org-src-container">

<pre class="src src-elixir"><span style="color: #F92672;">defmodule</span> <span style="color: #66D9EF;">MyApp.Mixfile</span> <span style="color: #F92672;">do</span>
  <span style="color: #F92672;">def</span> <span style="color: #A6E22E;">project</span> <span style="color: #F92672;">do</span>
    [<span style="color: #87cefa;">app:</span> <span style="color: #87cefa;">:my_app</span>,
     <span style="color: #87cefa;">deps:</span> deps]
  <span style="color: #F92672;">end</span>

  <span style="color: #F92672;">defp</span> <span style="color: #A6E22E;">deps</span> <span style="color: #F92672;">do</span>
    [{<span style="color: #87cefa;">:ecto</span>, <span style="color: #E6DB74;">"~&gt; 0.8.0"</span>}]
  <span style="color: #F92672;">end</span>
<span style="color: #F92672;">end</span>
</pre>
</div>

<p>
It's a neat pattern, and works well in simple modules like a
mixfile. I'd avoid using this when the function being called does
significant computation, as opposed to the <code>deps/0</code> function which
only returns a value.
</p>

<p>
See Avdi Grimm's <a href="http://devblog.avdi.org/2012/10/01/barewords/">barewords ruby tapas episode</a> for a great
description of this.
</p>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">Piping</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Empty trailing parentheses are unnecessary when using the pipe
macro.
</p>

<p>
A simple, contrived example:
</p>

<div class="org-src-container">

<pre class="src src-elixir">1..10
  |&gt; <span style="color: #AE81FF;">Enum</span>.count
  |&gt; <span style="color: #AE81FF;">IO</span>.inspect
</pre>
</div>

<pre class="example">
10
</pre>

<p>
When using piping, there is <i>no</i> ambiguity about what <code>Enum.count</code>
is referring to: it's being called as function with one
argument. Empty trailing parens provide no additional information.
</p>

<p>
However, in practice you'll often find yourself piping through
functions which take more than one argument, which muddies the
parens aesthetic situation a bit:
</p>

<div class="org-src-container">

<pre class="src src-elixir">1..10
  |&gt; <span style="color: #AE81FF;">Enum</span>.filter(&amp;(rem(&amp;1, 2) == 0))
  |&gt; <span style="color: #AE81FF;">Enum</span>.count
  |&gt; <span style="color: #AE81FF;">IO</span>.inspect
</pre>
</div>

<pre class="example">
5
</pre>

<p>
In sum, dropping parens when piping doesn't introduce ambiguity for
the reader. Use what works best for your situation.
</p>
</div>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">Readability</h3>
<div class="outline-text-3" id="text-3-3">
<p>
The argument goes that parantheses are noise, and getting rid of
them improves the clarity of your source. But, as argued above,
parens are <i>not</i> noise; their presence signals that name refers to
a 0-arity function.
</p>

<p>
As for the scannability of <code>func</code> vs <code>func()</code>, I'm not going to
argue aesthetics. Instead, I'll say that from Prolog to C to
mathematics, trailing parens as notation for a function call is
ubiquitous, arguments or no.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">Other</h2>
<div class="outline-text-2" id="text-4">
<ul class="org-ul">
<li>Discussion of parentheses in function definitions and piping
in <a href="https://github.com/niftyn8/elixir_style_guide/pull/3">the elixir style guide</a>.
</li>
</ul>
</div>
</div>

</div>
</div>
    <div>
      <div class="post-meta">
        <span title="post date" class="post-info">2015-03-12</span>
        <span title="last modification date" class="post-info">2015-03-15</span>
        <span title="tags" class="post-info"><a href="/tags/elixir/">elixir</a> <a href="/tags/style/">style</a></span>
        <span title="author" class="post-info">Thomas Moulia</span>
      </div>
      <section>
        <h1>Comments</h1>
      </section>
      <script src="http://code.jquery.com/jquery-latest.min.js"></script>
      <script src="https://google-code-prettify.googlecode.com/svn/loader/prettify.js"></script>
      <script src="/media/js/main.js"></script>
      <script type="text/javascript">
        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-60774978-1']);
        _gaq.push(['_trackPageview']);
        (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();
      </script>
      <div class="footer">
        <p>Generated by <a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.x (<a href="http://orgmode.org">Org mode</a> 8.x)</p>
        <p>
          Copyright &copy; 2012 - <span id="footerYear"></span> <a href="mailto:jtmoulia &lt;at&gt; gmail &lt;dot&gt; com">Thomas Moulia</a>
          &nbsp;&nbsp;-&nbsp;&nbsp;
          Powered by <a href="https://github.com/kelvinh/org-page" target="_blank">org-page</a>
          <script type="text/javascript">document.getElementById("footerYear").innerHTML = (new Date()).getFullYear();</script>
        </p>
      </div>
    </div>

  </body>
</html>
